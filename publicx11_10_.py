# -*- coding: utf-8 -*-
"""PublicX11.10..ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1G9kMxXZ1MMufYqEPd69xLrWfupRdafx6
"""

!npm install -g localtunnel
!sudo apt-get install xvfb xserver-xephyr tigervnc-standalone-server x11-utils gnumeric novnc
!apt-get update
!apt-get install -y wget unzip x11vnc
!pip install pyvirtualdisplay pillow EasyProcess websockets
# Install Chrome
!wget -q https://dl.google.com/linux/direct/google-chrome-stable_current_amd64.deb
!dpkg -i google-chrome-stable_current_amd64.deb
!npm install -g localtunnel
!apt --fix-broken install -y
from IPython.display import clear_output
import os
clear_output()
from easyprocess import EasyProcess
from pyvirtualdisplay import Display
from pyvirtualdisplay.smartdisplay import SmartDisplay
import threading , time , os , socket ,threading , requests , threading
from IPython.display import HTML , IFrame


def get_public_ip():
    response = requests.get('https://api.ipify.org?format=json')
    return response.json()['ip']
def get_available_port():
    # Create a socket using the IPv4 address family and TCP protocol
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

    # Bind to a port of value 0 which allows the OS to assign an available port
    sock.bind(('localhost', 0))

    # Retrieve the port number assigned by the OS
    port = sock.getsockname()[1]

    # Close the socket
    sock.close()

    return port



!rm nohup.out
!port_to_check=5900; pid=$(lsof -t -i:$port_to_check); if [ -n "$pid" ]; then echo "Process using port $port_to_check found with PID: $pid"; kill $pid; echo "Process with PID $pid terminated."; else echo "No process found using port $port_to_check."; fi
def background_task():
    with SmartDisplay(backend="xvnc", size=(1920, 1080),rfbport = 5900) as disp:
        os.environ['DISPLAY'] = f":{str(disp.display )}"
        with EasyProcess(["google-chrome" , "--no-sandbox" ,  "--app-url" , " https://www.google.com/" ])  as proc:
            time.sleep(5)

            img = disp.waitgrab()
            print(disp.display , file = open('debug.txt' , 'w'))
            #### save this image to local
            img.save('screenshot.png')  # Save the image to local file
            proc.wait()
            print("disp.display" , file = open('debug.txt' , 'w'))
# Start the background task in a separate thread

background_thread = threading.Thread(target=background_task)
background_thread.daemon = True
background_thread.start()
!port_to_check=6080; pid=$(lsof -t -i:$port_to_check); if [ -n "$pid" ]; then echo "Process using port $port_to_check found with PID: $pid"; kill $pid; echo "Process with PID $pid terminated."; else echo "No process found using port $port_to_check."; fi
public_ip = get_public_ip()

html_content = f"""

<div style="width: 100% , padding:12 ; display: flex;justify-content: center; ">
    <button id="copyButton" onclick="copyToClipboard()" style="width: 100%;margin: 12px ; padding: 12px">Copy Ip address</button>
    <script>
        function copyToClipboard() {{

            navigator.clipboard.writeText("{public_ip}") ;
        }}
    </script>
</div>
"""
display(HTML(html_content))

!port_to_check=6080; pid=$(lsof -t -i:$port_to_check); if [ -n "$pid" ]; then echo "Process using port $port_to_check found with PID: $pid"; kill $pid; echo "Process with PID $pid terminated."; else echo "No process found using port $port_to_check."; fi
!nohup /usr/share/novnc/utils/launch.sh --vnc localhost:5900 > novnc.log 2>&1 &
import multiprocessing
import asyncio
import websockets
from urllib.parse import urljoin

async def forward(websocket, path):
    # Replace with the actual WebSocket server URL
    target_uri = f"ws://{your_werequests.get('https://api.ipify.org?format=json').json().get('ip')}:5900"


    async with websockets.connect(target_uri) as target_websocket:
        while True:
            try:
                # Forward messages from the client to the target WebSocket server
                client_message = await websocket.recv()
                await target_websocket.send(client_message)

                # Forward responses from the target WebSocket server back to the client
                server_response = await target_websocket.recv()
                await websocket.send(server_response)
            except websockets.exceptions.ConnectionClosed:
                break

def run_websocket_proxy():
    loop = asyncio.new_event_loop()
    asyncio.set_event_loop(loop)
    loop.run_until_complete(websockets.serve(forward, socket.gethostname() , 6080))
    loop.run_forever()

if __name__ == "__main__":
    # Create a separate process to run the WebSocket proxy
    !nohup lt --port 6080 > server.log 2>&1 &
    websocket_proxy_process = multiprocessing.Process(target=run_websocket_proxy)
    websocket_proxy_process.start()
    time.sleep(5)
    url_screen = open("server.log").read().strip().replace('your url is: ','')
    print(url_screen)
    print(urljoin(url_screen, f"/vnc.html?host={socket.gethostname()}&port=6080"))
    websocket_proxy_process.join()